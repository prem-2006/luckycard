**IMPORTANT: Return ONLY the updated files (.ts, .tsx, and README.md). No explanations.**

## Contract Details
- Contract address: `0x270455692EFc56c5A88e946194be5C3E2A7dc29c`
- https://coston2-explorer.flare.network/address/0x270455692EFc56c5A88e946194be5C3E2A7dc29c
- Contract source: `lib/contract.ts`
- Hook: `hooks/useContract.ts`
- Sample UI: `components/sample.tsx`

---

# File 1: `lib/contract.ts`

```ts
export const contractAddress = "0x270455692EFc56c5A88e946194be5C3E2A7dc29c";

// Export only the ABI array expected by viem/wagmi
export const contractABI = [
  {
    "inputs": [],
    "name": "drawCard",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "lastCard",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "myLuckyCard",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
] as const;
```

---

# File 2: `hooks/useContract.ts`

```ts
"use client"

import { useState, useEffect } from "react"
import { useAccount, useReadContract, useWriteContract, useWaitForTransactionReceipt } from "wagmi"
import { formatEther } from "viem"
import { contractABI, contractAddress } from "@/lib/contract"

export interface ContractData {
  contractBalance: string
  myCard: string
}

export interface ContractState {
  isLoading: boolean
  isPending: boolean
  isConfirming: boolean
  isConfirmed: boolean
  hash: `0x${string}` | undefined
  error: Error | null
}

export interface ContractActions {
  drawCard: () => Promise<void>
}

export const useLuckyCardContract = () => {
  const { address } = useAccount()
  const [isLoading, setIsLoading] = useState(false)

  const { data: contractBalance, refetch: refetchBalance } = useReadContract({
    address: contractAddress,
    abi: contractABI,
    functionName: "myLuckyCard",
    query: { enabled: false }
  })

  const { data: myCard, refetch: refetchMyCard } = useReadContract({
    address: contractAddress,
    abi: contractABI,
    functionName: "myLuckyCard",
    query: { enabled: !!address }
  })

  const { writeContractAsync, data: hash, error, isPending } = useWriteContract()

  const { isLoading: isConfirming, isSuccess: isConfirmed } = useWaitForTransactionReceipt({ hash })

  useEffect(() => {
    if (isConfirmed) {
      refetchBalance()
      refetchMyCard()
    }
  }, [isConfirmed, refetchBalance, refetchMyCard])

  const drawCardAction = async () => {
    try {
      setIsLoading(true)
      await writeContractAsync({
        address: contractAddress,
        abi: contractABI,
        functionName: "drawCard",
      })
    } finally {
      setIsLoading(false)
    }
  }

  const data: ContractData = {
    contractBalance: contractBalance ? formatEther(BigInt(0)) : "0",
    myCard: myCard ? (myCard as string) : ""
  }

  const actions: ContractActions = { drawCard: drawCardAction }

  const state: ContractState = {
    isLoading: isLoading || isPending || isConfirming,
    isPending,
    isConfirming,
    isConfirmed,
    hash,
    error
  }

  return { data, actions, state }
}

```

---

# File 3: `components/sample.tsx`

```tsx
"use client"

import { useState } from "react"
import { useAccount } from "wagmi"
import { useLuckyCardContract } from "@/hooks/useContract"
import { isAddress } from "viem"

const LuckyCardSample = () => {
  const { isConnected } = useAccount()
  const { data, actions, state } = useLuckyCardContract()
  const [txHash, setTxHash] = useState("")

  if (!isConnected) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center p-4">
        <div className="max-w-md w-full">
          <h2 className="text-2xl font-bold text-foreground mb-3">Lucky Card</h2>
          <p className="text-muted-foreground">Connect wallet to draw your lucky card.</p>
        </div>
      </div>
    )
  }

  const handleDraw = async () => {
    try {
      const tx = await actions.drawCard()
      if (tx) setTxHash(tx)
    } catch {}
  }

  return (
    <div className="min-h-screen bg-background p-6 flex justify-center items-center">
      <div className="bg-card border border-border rounded-xl shadow-md p-6 w-full max-w-md space-y-4">
        <h1 className="text-xl font-bold">Lucky Card Draw</h1>
        {data.myCard && (
          <div className="p-4 bg-muted rounded-lg text-center text-lg">{data.myCard}</div>
        )}
        <button
          onClick={handleDraw}
          disabled={state.isLoading || state.isPending}
          className="w-full px-6 py-2 bg-primary text-primary-foreground rounded-lg hover:opacity-90 disabled:opacity-50"
        >
          {state.isLoading || state.isPending ? "Drawing..." : "Draw Lucky Card"}
        </button>
        {txHash && (
          <div className="p-3 bg-muted rounded-lg text-xs font-mono break-all">
            {txHash}
          </div>
        )}
      </div>
    </div>
  )
}

export default LuckyCardSample

```

---

# File 4: `README.md`

Create a comprehensive README.md file in a separate markdown file with the following sections:

1. **Project Title**: A clear and descriptive title for the project
2. **Contract Address**: `0x270455692EFc56c5A88e946194be5C3E2A7dc29c` (https://coston2-explorer.flare.network/address/0x270455692EFc56c5A88e946194be5C3E2A7dc29c)
3. **Description**: A detailed description of what the project does, its purpose, and its main functionality
4. **Features**: A well-structured list of key features and capabilities of the project
5. **How It Solves**: A detailed explanation of the problem this project addresses and how it provides a solution, including use cases and benefits

Write the README in a professional, well-descriptive manner that clearly communicates the project's value proposition and technical details.

---

Update the hook and UI to use the contract above. Keep wallet gating, loading state, and error handling intact.